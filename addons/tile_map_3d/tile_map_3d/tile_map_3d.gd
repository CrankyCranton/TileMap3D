## The 3D equivalent to the TileMap. It draws the tiles.
## NOTE: As of Godot 4, the TileMap as gotten a lot better.
## This node has lagged behind and has not added to it's feature list much.
@tool
@icon("res://addons/tile_map_3d/tile_map_3d/icon.svg")
class_name TileMap3D
extends GridMap


## Contains the tile set data resource. The data is generated by [TileSet3D].
## It is in the following format (question marks indicate that a dictionary key might/might not be there):
## [{?scene? = <scene>, ?bitmasks? = [{orientation = <orientation>, priority = <priority>, ?bitmask? = {<cell> = <tile_id>}]}]
@export var tile_set: TileSetData = null:
	set(value):
		tile_set = value
		update()
## The seed used for tiles in need of priority.
## Priority is only used when there are multiple different tiles that all have a bitmask that could fit for a singal cell.
@export var seed := 0:
	set(value):
		seed = value
		_rng.seed = seed
		update()
@export var _update := false:
	set(_value):
		update()

var _rng := RandomNumberGenerator.new()
#var _last_cells := []


#func _process(_delta: float) -> void:
#	if get_used_cells() != _last_cells:# doesn't work properly
#		update()
#		_last_cells = get_used_cells()


func _ready() -> void:
	if not Engine.is_editor_hint():
		update()


func _notification(what: int) -> void:
	if what == NOTIFICATION_DRAG_END:
		print("drag ended")
		update()


## Upates auto-tiling and priority of the TileMap3D.
## This also updates tile scene instantiation, but only when the game is running.
func update() -> void:
	if not _check_data_errors():
		return

	for cell in get_used_cells():
		auto_tile(cell)

		if (not Engine.is_editor_hint()) and tile_set.data[get_cell_item(cell)].has("scene"):
			var scene: Node3D = tile_set.data[get_cell_item(cell)].scene.instantiate()
			add_child(scene)
			scene.global_position = map_to_local(cell)
			scene.basis = get_cell_item_basis(cell)

			set_cell_item(cell, INVALID_CELL_ITEM)


## Updates the auto-tiling of 'cell'. Used by 'update()'.
func auto_tile(cell: Vector3i) -> void:
	if not _check_data_errors():
		return

	var tile_options := get_tile_options(cell)
	if tile_options.size() > 0:
		var rand_num := _rng.randi_range(1, tile_set.get_total_priority(tile_options))
		var current_num := 0
		var selected_tile := {}
		# Sorting shouldn't matter functionality wise.
		# TODO: Sort from greatest to least if it improves performance, else remove sorting.
		tile_options.sort()
		for tile in tile_options:
			current_num += tile.priority
			if rand_num <= current_num:
				selected_tile = tile
				break

		set_cell_item(cell, selected_tile.index, selected_tile.orientation)


## Returns an [Array][[Dictionary]] of the avalible tiles for the given cell. Used by 'update()'.
func get_tile_options(cell: Vector3i) -> Array[Dictionary]:
	if not _check_data_errors():
		return []

	var tiles: Array[Dictionary] = []
	for i in tile_set.data.size():
		if not tile_set.data[i].has("bitmasks"):
			continue
		for bitmask_data in tile_set.data[i].bitmasks:
			var matches := true
			if bitmask_data.has("bitmask"):
				for bitmask_cell in bitmask_data.bitmask:
					var bitmask_position: Vector3 = cell + bitmask_cell
					var cell_item := clampi(get_cell_item(bitmask_position), -1, 0)
					if cell_item != bitmask_data.bitmask[bitmask_cell] - 1:
						matches = false
						break

			if matches:
				tiles.append({
					index = i,
					orientation = bitmask_data.orientation,
					priority = bitmask_data.priority,
				})

	return tiles


func _check_data_errors() -> bool:
	if tile_set == null:
		push_error("Could not load tile set data.")
		return false
	if tile_set.data == []:
		push_warning("The tile set data is empty.")
		return false
	return true
